---
title: "Pilot Analysis"
author: "Howard Baek"
date: "6/17/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Libraries and Source
```{r}
library(tidyverse)
library(lubridate)
library(scales)
library(factoextra)
library(raster)
library(tmap)
library(png)
library(gridExtra)
library(dendextend)
library(DescTools)
theme_set(theme_light())

source(file.path(here::here(), "R", "imgVectortoRaster.R"))
source(file.path(here::here(), "R", "dendIMG.R"))
source(file.path(here::here(), "R", "myheatmap.R"))
source(file.path(here::here(), "R", "desat.R"))
source(file.path(here::here(), "R", "kheatmap.R"))
source(file.path(here::here(), "R", "addIMGtopanel.R"))
source(file.path(here::here(), "R", "yearTable.R"))
# Code to download data from ERDDAP servers is in data folder
```


# Re-run Eli talk analyses 

Latitude (42.625, 52.125) and Longitude (229.875, 236.625)

## Data Preprocessing
```{r}
# I downloaded the data using read_csv("https://coastwatch.pfeg.noaa.gov/erddap/griddap/ncdcOisst21Agg.csv?sst%5B(2010-01-01T12:00:00Z):(2021-06-01T12:00:00Z)%5D%5B(0.0)%5D%5B(42.625):(52.125)%5D%5B(229.875):(236.625)%5D&.draw=surface&.vars=longitude%7Clatitude%7Csst&.colorBar=%7C%7C%7C12%7C19%7C&.bgColor=0xffccccff")
# This big data is saved as pilot_data.csv

# Raw data (last 10 years)
df_raw <- read_csv("howard-analysis/pilot_data.csv")

# Processed data
df_processed <- df_raw %>% 
  # Get rid of miscellaneous zlev in first row
  slice(-1) %>% 
  # zlev is a column of zeroes, so get rid of that
  dplyr::select(-zlev) %>% 
  # Convert into date
  mutate(time = ymd_hms(time),
         # Extract out day so I can just filter for first day in each month
         day = day(time)) %>% 
  # filter for first day in each month
  filter(day == 1) %>% 
  dplyr::select(-day) %>% 
  # Set column names
  rename(date = time,
         lat = latitude,
         lon = longitude) %>% 
  # Convert date column to Date type
  mutate(date = as.Date(date),
         lat = as.numeric(lat),
         lon = as.numeric(lon),
         sst = as.numeric(sst))
```

```{r}
# Check if same n for each date
n.by.date <- tapply(df_processed$sst, df_processed$date, function(x){sum(is.na(x))})
if(any((n.by.date-n.by.date[1])!=0)) {
  stop("There's a problem. Should be same n for each date.")
} 

# Pivot Wider
df_wide <- df_processed %>% 
  pivot_wider(names_from = date, values_from = sst)

# which row are non-NA?
pos_loc <- which(!is.na(df_wide[,3]))

# Omit data and take transpose
df_clean <- df_wide %>% 
  # remove the rows that are NA
  na.omit()

# Take transpose of df_wide and df_clean to mimic output of processCSV-tidyverse.R
df_wide_t <- t(df_wide)
df_clean_t <- t(df_clean)

datalist <- list(dat = df_wide_t, dat_clean = df_clean_t, pos_loc = pos_loc)
```


```{r}
# Take out rows with lat, lon
image <- df_clean_t[c(-1,-2),]
# image %>% View()

# Create image_norm (X_norm in QuanSeminar.Rmd)
image_norm <- t(scale(t(image), scale=FALSE))
colnames(image_norm) <- paste0("p", 1:ncol(image_norm))

# image_norm %>% View()
```


Note: image_norm is a 138 by 805 matrix (Context: 138 images on 138 different dates, first day of each month from the past 10 years, with 805 pixels)

```{r}
round(image_norm[1:5, 1:10], digits=2)
```


## PCA

```{r}
# Apply PCA
prcomp_pca <- prcomp(image_norm, scale = FALSE, center=FALSE)

# Do this so the first eigenimage looks like upwelling
# each column in prcomp_pca$rotation is an "eigenimage"
prcomp_pca$rotation[,1] <- -1 * prcomp_pca$rotation[,1]
prcomp_pca$x[,1] <- -1 * prcomp_pca$x[,1]

# Store for use later
eigenimages <- t(prcomp_pca$rotation)
alpha <- prcomp_pca$x
```

`eigenimages` is a 138 by 805 matrix, where where are 138 PCs (eigenimages) and 805 pixels (p1, p2, p3, ..., p805)


```{r}
df <- data.frame(alpha,
                date = as.Date(rownames(image_norm)),
                year=as.integer(format(as.Date(rownames(image_norm)), "%Y")),
                mon=factor(format(as.Date(rownames(image_norm)), "%b"), levels = month.abb))
# Get rid of rownames
rownames(df) <- NULL
# Make date_label for graph
df <- df %>% 
  mutate(date_label = paste(mon, year, sep = ","))

df2 <- df %>% 
  pivot_longer(starts_with("PC"), names_to="PC", values_to="value")
```



### PC1 and PC2
```{r}
# Visualize PCs
# Recreate Eli's graph: SST Anomaly pattern in the PC1-PC2 space
df %>% 
  ggplot(aes(PC1, PC2, label = date_label)) +
  geom_point(alpha = 0.3) +
  geom_text(check_overlap = TRUE, vjust = 1, hjust = 1) +
  annotate("segment", x = -5, xend = 55, y = 0, yend = 0, colour = "midnightblue", linetype=2) +
  annotate("segment", x = 0, xend = 0, y = -25, yend = 25, colour = "midnightblue", linetype=2) +
  ggtitle("PCA clusters months together",
          subtitle = "April&May&June and Feb&March and July&August and Sept&Oct") 
```

### PCA: Facet by month
```{r}
df %>% 
  ggplot(aes(PC1, PC2, label = year)) +
  geom_point(alpha = 0.8) +
  geom_text(check_overlap = TRUE, vjust = 1, hjust = 1) +
  facet_wrap(~mon) +
  annotate("segment", x = -5, xend = 55, y = 0, yend = 0, colour = "midnightblue", linetype=2) +
  annotate("segment", x = 0, xend = 0, y = -25, yend = 25, colour = "midnightblue", linetype=2) +
  ggtitle("PCA decomposition into PC1 and PC2 by Month",
          subtitle = "Shows seasonal cycle: Parabolic Movement from Jan to Dec") 
```


### PCA: Facet by Year
```{r}
df %>%
  ggplot(aes(PC1, PC2, label = mon, vjust = 1, hjust = 1)) +
  geom_point(alpha = 0.8) +
  geom_text(check_overlap = TRUE) +
  facet_wrap(~year) +
  annotate("segment", x = -5, xend = 55, y = 0, yend = 0, colour = "midnightblue", linetype=2) +
  annotate("segment", x = 0, xend = 0, y = -25, yend = 25, colour = "midnightblue", linetype=2) +
   ggtitle("PCA decomposition into PC1 and PC2 by Year",
          subtitle = "Shows seasonal cycle, missing summer months for 2021") 
```


### Vector to Raster (img_list)
```{r}
# imgVectortoRaster function
n_K <- nrow(eigenimages)

# Get out dirty data
Data_dirty <- datalist$dat
# Latitude of dirty data
lats <- Data_dirty[1,]
# Longitude of dirty data
lons <- Data_dirty[2,]
# Aspect of dirty data
asp <- c(table(lons)[1], table(lats)[1]) # lon (x) - lats (y)
# bbox is a bounding box (minx, maxx, miny, maxy)
bb_box <- c(min(lons), max(lons), min(lats), max(lats))
# 229.875 236.625  42.625  52.125 
# matches the box set on ERDDAP link

# Populate non-NA columns (indicated by pos.loc) of centroid_images with centers
centroid_images <- matrix(NA, n_K, ncol(Data_dirty))
centroid_images[, datalist$pos_loc] <- eigenimages
rownames(centroid_images) <- paste("Centroid", 1:n_K)

# Empty list 
img_list <- list()
# Assign img_mat
img_mat <- centroid_images

# For each centroid (row in img_mat)
for(i in 1:nrow(img_mat)){
  
  tmp <- matrix(img_mat[i,], asp[2], asp[1], byrow=TRUE)
  tmp <- tmp[asp[2]:1, ] # inverse order of rows
  # Convert tmp to raster
  tmp <- raster::raster(tmp)
  # Set extent of raster
  # The spatial extent is the allowable range for x and y coordinates 
  # When you create a feature class or feature dataset, the spatial extent is defined using 
  # minimum and maximum x and y coordinate values.
  raster::extent(tmp) <- bb_box
  # crs is a coordinate reference system
  raster::crs(tmp) <- "+proj=longlat +datum=WGS84"
  img_list[[i]] <- tmp
}

# Create a RasterStack object
img_stack <- raster::stack(img_list)
names(img_stack) <- paste("Centroid", 1:n_K)
# crs is a coordinate reference system
raster::crs(img_stack) <- "+proj=longlat +datum=WGS84"
```

Something is wrong. I get NA values inside img_list (values)
UPDATE: I fixed pos.loc to pos_loc inside imgVectortoRaster.R


### PCA: 6 Eigen Images
```{r}
# First 6 eigenimages
p_stack <- raster::stack(img_list[[1]], img_list[[2]], img_list[[3]], 
                 img_list[[4]], img_list[[5]], img_list[[6]])

pal <- colorRamps::matlab.like(100)

# crs(p_stack) <- "+proj=longlat +datum=WGS84"

tm_shape(p_stack) +  
  tm_raster(style= "cont", title="SST Anomaly", 
            palette=pal, midpoint=NA, 
            colorNA = "grey", textNA = "Land") +
  tm_layout(panel.labels = paste("PC", 1:length(p_stack))) +
  tm_layout(main.title = "Eigen Images", title.size = 1)
```

Image looks wrong.





## K-Means Clustering
```{r}
set.seed(123)
n_K <- 12
out_norm <- kmeans(image_norm, n_K, iter.max=25, nstart=100)
```


```{r}
centroidimages_norm <- out_norm$centers
rownames(centroidimages_norm) <- paste("Centroid", 1:n_K)
round(centroidimages_norm[1:5, 1:5], digits=2)
```

```{r}
img_norm <- imgVectortoRaster(centroidimages_norm, datalist)
img_norm_stack <- img_norm$stack
img_norm_list <- img_norm$list
```

### Centroid Images
```{r}
tm_shape(img_norm_stack) + 
  tm_raster(style= "cont", title="SST Anomaly", 
            palette=pal, midpoint=NA, 
            colorNA = "grey", textNA = "Land") +
  tm_layout(panel.labels = paste("Centroid", 1:length(p_stack))) +
  tm_layout(main.title = "Centroid Images", title.size = 1)
```


### Distances between Images
```{r}
p12 <- kheatmap(12, image_norm, datalist, main.n=5, plotit=FALSE, dend.type="original")
```

